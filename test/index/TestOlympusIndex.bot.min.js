const log = require("../utils/log");
const calc = require("../utils/calc");
const {
  DerivativeProviders,
  ethToken,
  DerivativeStatus,
  WhitelistType,
  DerivativeType
} = require("../utils/constants");

const OlympusIndex = artifacts.require("OlympusIndex");
const Rebalance = artifacts.require("RebalanceProvider");
const RiskControl = artifacts.require("RiskControl");
const StepProvider = artifacts.require("StepProvider");
const Marketplace = artifacts.require("Marketplace");
const Whitelist = artifacts.require("WhitelistProvider");
const Withdraw = artifacts.require("AsyncWithdraw");
const Locker = artifacts.require("Locker");
const MockToken = artifacts.require("MockToken");
const ComponentList = artifacts.require("ComponentList");

const PercentageFee = artifacts.require("PercentageFee");
const Reimbursable = artifacts.require("Reimbursable");

// Buy and sell tokens
const ExchangeProvider = artifacts.require("../contracts/components/exchange/ExchangeProvider");
const MockKyberNetwork = artifacts.require("../contracts/components/exchange/exchanges/MockKyberNetwork");
const ERC20 = artifacts.require("../contracts/libs/ERC20Extended");
//  1%, 9%, 2%, 8%, 3%, 7%, 4%, 6%, 5%, 10%, 15%, 20%, 2.2%, 4.55%, 3.25%

const indexData = {
  name: "OlympusIndex",
  symbol: "OlympusIndex",
  description: "Sample of real index",
  category: "Index",
  decimals: 18,
  managementFee: 0,
  initialManagementFee: 0,
  wrongEthDeposit: 0.05,
  ethDeposit: 0.1,
  //   weights: [10, 1, 29, 5, 5, 10, 20, 10, 10],
  weights: [1, 9, 2, 8, 3, 7, 4, 6, 5, 10, 15, 20, 2, 5, 3],
  rebalanceDelta: 0
};

let processingBuyToken = false;
let processingRebalance = false;
let processingWithdraw = false;

const expectedTokenAmount = (balance, rates, tokenIndex) => {
  // Balance ETH * (weight)%  * tokenRate / ETH  ==> Expected tokenAmount
  return (balance * (indexData.weights[tokenIndex] / 100) * rates[0][tokenIndex].toNumber()) / 10 ** 18;
};

const getTokensAndAmounts = async index => {
  const tokensWeights = await index.getTokens();
  const amounts = await Promise.all(
    tokensWeights[0].map(async token => {
      let erc20 = await ERC20.at(token);
      return erc20.balanceOf(index.address);
    })
  );
  return [tokensWeights[0], amounts];
};

const toTokenWei = amount => {
  return amount * 10 ** indexData.decimals;
};

const delay = async sec => {
  return new Promise(resolve => {
    setTimeout(resolve, sec);
  });
};

const availableStatus = async (index, current) => {
  const status = await index.productStatus();
  return status.toNumber() === 0 || status.toNumber() === current;
};

const availableWithdraw = async (index, asyncWithdraw) => {
  const available = await availableStatus(index, 1);
  const totalRequest = (await asyncWithdraw.getContractInfo(index.address))[2].toNumber();
  return available && totalRequest > 0;
};

const availableRebalance = async (index, rebalanceProvider) => {
  const available = await availableStatus(index, 2);
  try {
    const needs = await rebalanceProvider.needsRebalance.call(1, index.address);
    return available && needs;
  } catch (err) {
    console.log("err", err);
    return false;
  }
};

const availableBuyTokens = async index => {
  const available = await availableStatus(index, 3);
  let balance = (await index.getETHBalance()).toNumber();
  const result = available && balance > 1000;
  return result;
};

const safeRebalance = async (index, rebalanceProvider) => {
  if (processingRebalance) return;

  if (!availableRebalance(index, rebalanceProvider)) {
    return;
  }

  processingRebalance = true;

  try {
    const result = await index.rebalance.call();
    await index.rebalance();
    processingRebalance = false;
    if (!result) {
      console.log("safeRebalance:", result);
      await safeRebalance(index, rebalanceProvider);
    } else {
      console.log("rebalance done");
    }
  } catch (e) {
    if (e.message.includes("revert")) {
      console.log("safeRebalance revert");
      status = await index.productStatus();
      console.log("index status:", status.toNumber());
      await delay(1000);
      processingRebalance = false;
      await safeRebalance(index, rebalanceProvider);
    }
  }
};

const safeWithdraw = async (index, asyncWithdraw, force = false) => {
  if (processingWithdraw) return;
  if (!force && !(await availableWithdraw(index, asyncWithdraw))) {
    return;
  }

  processingWithdraw = true;

  try {
    const result = await index.withdraw.call();
    await index.withdraw();
    processingWithdraw = false;
    if (!result) {
      console.log("safeWithdraw:", result);
      await safeWithdraw(index, asyncWithdraw);
    } else {
      console.log("withdraw done");
    }
  } catch (e) {
    if (e.message.includes("revert")) {
      const status = await index.productStatus();
      console.log("safeWithdraw revert", status.toNumber());
      await delay(1000);
      processingWithdraw = false;
      await safeWithdraw(index, asyncWithdraw);
      return;
    }

    throw e;
  }
};

const safeBuyTokens = async index => {
  if (processingBuyToken) return;

  if (!(await availableBuyTokens(index))) {
    return;
  }

  processingBuyToken = true;
  console.log("start buy token .......");
  try {
    const result = await index.buyTokens.call();
    console.log("buy tokens result", result);
    await index.buyTokens();

    processingBuyToken = false;
    if (!result) {
      console.log("buy token not finish", result);
      await safeBuyTokens(index);
    } else {
      console.log("buy tokens done");
    }
  } catch (e) {
    if (e.message.includes("revert")) {
      const status = await index.productStatus();
      console.log("safeBuyTokens revert", status.toNumber());
      await delay(1000);
      processingBuyToken = false;
      await safeBuyTokens(index);
      return;
    }

    throw e;
  }
};

contract("Olympus Index Bot Reduced", accounts => {
  let index;
  let market;
  let mockKyber;
  let mockMOT;
  let exchange;
  let asyncWithdraw;
  let rebalance;
  let tokens;
  let componentList;
  let erc20Token0;
  let erc20Token1;
  let erc20Token2;
  let erc20Token3;
  let allDone = false;

  const investorsGroupA = accounts.slice(1, 11);

  before("Initialize tokens", async () => {
    assert(accounts.length >= 11, "Require at least 11 investors for this test case");

    mockKyber = await MockKyberNetwork.deployed();
    const mockTokens = await mockKyber.supportedTokens();
    tokens = mockTokens.slice(0, indexData.weights.length);
    market = await Marketplace.deployed();
    mockMOT = await MockToken.deployed();
    exchange = await ExchangeProvider.deployed();
    asyncWithdraw = await Withdraw.deployed();
    locker = await Locker.deployed();
    riskControl = await RiskControl.deployed();
    percentageFee = await PercentageFee.deployed();
    rebalance = await Rebalance.deployed();
    whitelist = await Whitelist.deployed();
    reimbursable = await Reimbursable.deployed();
    componentList = await ComponentList.deployed();
    stepProvider = await StepProvider.deployed();

    await exchange.setMotAddress(mockMOT.address);
    await asyncWithdraw.setMotAddress(mockMOT.address);
    await riskControl.setMotAddress(mockMOT.address);
    await percentageFee.setMotAddress(mockMOT.address);
    await rebalance.setMotAddress(mockMOT.address);
    await whitelist.setMotAddress(mockMOT.address);
    await reimbursable.setMotAddress(mockMOT.address);
    await mockKyber.setSlippageMockRate(100);

    componentList.setComponent(DerivativeProviders.MARKET, market.address);
    componentList.setComponent(DerivativeProviders.EXCHANGE, exchange.address);
    componentList.setComponent(DerivativeProviders.WITHDRAW, asyncWithdraw.address);
    componentList.setComponent(DerivativeProviders.LOCKER, locker.address);
    componentList.setComponent(DerivativeProviders.RISK, riskControl.address);
    componentList.setComponent(DerivativeProviders.FEE, percentageFee.address);
    componentList.setComponent(DerivativeProviders.WHITELIST, whitelist.address);
    componentList.setComponent(DerivativeProviders.REIMBURSABLE, reimbursable.address);
    componentList.setComponent(DerivativeProviders.REBALANCE, rebalance.address);
    componentList.setComponent(DerivativeProviders.STEP, stepProvider.address);

    erc20Token0 = await ERC20.at(await tokens[0]);
    erc20Token1 = await ERC20.at(await tokens[1]);
    erc20Token2 = await ERC20.at(await tokens[2]);
    erc20Token3 = await ERC20.at(await tokens[3]);

    mockKyber.sendTransaction({ value: calc.toWei(10) })


  });

  it("Deploy index should be success", async () => {
    index = await OlympusIndex.new(
      indexData.name,
      indexData.symbol,
      indexData.description,
      indexData.category,
      indexData.decimals,
      tokens,
      indexData.weights,
      {
        gas: 8e6
      }
    );

    let status = (await index.status()).toNumber();
    assert.equal(status, 0, "step 1. Deploy should be success and status should be new");

    await index.initialize(componentList.address, indexData.initialManagementFee, indexData.rebalanceDelta, {
      value: web3.toWei(indexData.ethDeposit, "ether")
    });



    price = (await index.getPrice()).toNumber();
    assert.equal(price, web3.toWei(1, "ether"), "step 1. Price is 1 ether");

    balance = (await index.getETHBalance()).toNumber();
    assert.equal(balance, web3.toWei(0, "ether"), "step 1. Total ETH balance now is 0");

    const assetsValue = (await index.getAssetsValue()).toNumber();
    assert.equal(assetsValue, web3.toWei(0, "ether"), "step 1. Total assets value is 0 ETH");
  });

  it("buy tokens, withdraw and rebalance", async () => {
    // 1. Sends another 100 MOT to the index;
    await erc20Token0.transfer(index.address, web3.toWei(50, "ether"), {
      from: accounts[0]
    });

    // 2. Group A 10 investors each invests 0.1 ETH;
    await Promise.all(
      investorsGroupA.map(
        async account =>
          await index.invest({
            value: web3.toWei(1, "ether"),
            from: account
          })
      )
    );

    await safeBuyTokens(index);
    await index.withdraw();
    // 1. Group A investors each requests withdraw of 0.1 ETH;
    await Promise.all(
      investorsGroupA.map(async account => {
        const amount = (await index.balanceOf(account)).toNumber();
        await index.requestWithdraw(toTokenWei(0.1), {
          from: account
        });
      })
    );
    await safeWithdraw(index, asyncWithdraw);
    // 2. Owner closes the index;
    await index.close();

    // 3. Group A investors each requests withdraw rest of investment;
    await Promise.all(
      investorsGroupA.map(async account => {
        const amount = await index.balanceOf(account);

        await index.requestWithdraw(amount.sub(20), {
          from: account
        });
      })
    );

    await safeWithdraw(index, asyncWithdraw);

    await Promise.all(
      investorsGroupA.map(async account => {
        const amount = (await index.balanceOf(account)).toNumber();
      })
    );

    let balance = (await index.getETHBalance()).toNumber();
    assert(calc.inRange(calc.fromWei(balance), 0, 0.00001), "Total ETH balance now is 0");

    let assetsValue = (await index.getAssetsValue());
    assert(assetsValue.gt(calc.toWei(0)), "Total assets value should be 0");

    let totalSupply = await index.totalSupply();

    let price = (await index.getPrice());
    assert(price.gt(calc.toWei(1)), "Price is above 1");
    assert.isBelow(price.lt(calc.toWei(1.1)), "Price is less than 1.1");

    // withdraw the 20 wei for each account ,the price should become 1.
    await Promise.all(
      investorsGroupA.map(async account => {
        const amount = await index.balanceOf(account);

        await index.requestWithdraw(amount, { from: account });
      })
    );

    await safeWithdraw(index, asyncWithdraw);

    balance = (await index.getETHBalance()).toNumber();

    assetsValue = (await index.getAssetsValue()).toNumber();

    totalSupply = await index.totalSupply();

    price = (await index.getPrice()).toNumber();

    assert.equal(price, web3.toWei(1, "ether"), "Price is 1");
  });
});
